package photo;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Observable;
import java.util.Set;
import java.util.logging.Level;

import manager.MyLogging;

/**
 * Implements Observer Design Pattern
 * Photo class saves information of the photo and generate the photo's tags and
 * afford some useful function for PhotoManager. Notice: '@' and '/' are not
 * permitted in the Original name of photos without tags.
 */
public class Photo extends Observable implements Serializable {

	// tags can be generated by split the stream
	// by '@' and using getTags to get its value.
	private Set<String> tags;

	// Store the name with corresponding date.
	private Map<Date, String> nameHistory;

	// Used for separating the tag.
	private static final String tagSeparateSymbol = "@";

	// UID for serialization.
	private static final long serialVersionUID = 3950536640070526729L;

	private String photoPath;

	private String currentName;

	private String currNameWithoutTags;

	/**
	 * Create a photo without tags.
	 * 
	 * @param name:
	 *                photo's name without tags.
	 */
	public Photo(String pathName) {
		this.photoPath = pathName;
		String[] pathList = pathName.split("/");
		this.currNameWithoutTags = pathList[pathList.length - 1];
		this.currentName = pathList[pathList.length - 1];
		Date date = new Date();
		this.nameHistory = new LinkedHashMap<Date, String>();
		this.nameHistory.put(date, this.currentName);
		this.tags = new HashSet<String>();
		MyLogging.log(Level.FINE, "Instantiate the photo with original " + "name: " + this.currentName);
	}

	/**
	 * Get the tags of photo from currentName by splitting it with '@'.
	 * 
	 * @return Set of String
	 */
	public Set<String> generateTagsFromName() {
		String[] array1 = this.currentName.split(" @");
		int len = array1.length;
		Set<String> set = new HashSet<String>();
		if (len > 1) {
			for (int k = 1; k < len; k++) {
				set.add(array1[k]);
			}
		}
		return set;
	}

	public Set<String> getTags() {
		return this.tags;
	}

	/**
	 * Get the current name of photo
	 * 
	 * @return name of the photo.
	 */
	public String getCurrentName() {
		return this.currentName;
	}

	/**
	 * Get all the names of the photo had.
	 * 
	 * @return all names of the photo.
	 */
	public Collection<String> getAllHistoryNames() {
		return this.nameHistory.values();
	}

	public <T, E> T getTimeByName(Map<T, E> nameHistory, E name) {
		for (Entry<T, E> entry : nameHistory.entrySet()) {
			if (Objects.equals(name, entry.getValue())) {
				return entry.getKey();
			}
		}
		return null;
	}

	public String getTimeStamp(Photo photo, String name) {
		Date date = photo.getTimeByName(photo.nameHistory, name);
		return date.toString();
	}

	/**
	 * Add tags for an photo and renames the photo file name Note that only
	 * rename the photo's real name won't delete the tags.
	 * 
	 * @param date:
	 *                the time when adding tag
	 * @param newName:
	 *                the new name we want to rewrite
	 * @param onlyName:
	 *                if the user just want to change the photo's name it
	 *                should be false when add and delete tags
	 */
	public void renamePhoto(Date date, String newName, boolean onlyName) {
		// let the currentName to be the new name
		// this is the case that we change the tag
		if (!onlyName) {
			this.currentName = newName;
			// if we don't change the name of photo, then this won't
			// change. Use " @" is to prevent the name without tags
			// get useless space, using trim may have bugs cuz the
			// name might have 2 words.
			String[] nm1 = this.currentName.split(" @");
			this.currNameWithoutTags = nm1[0];
			// we also need to update the tags(Not only add and
			// delete tags will call this method so we still need
			// to get the tags)
			this.tags = this.generateTagsFromName();
			MyLogging.log(Level.FINE, "Change the name for photo:" + this.currNameWithoutTags
					+ " with tags: " + this.tags.toString() + "\n");
			// this is the case that we only change the name
		} else {
			// it's helpful to get name without tags when you rename
			// photo
			String[] nm2 = this.currentName.split(" @");
			this.currNameWithoutTags = newName;
			// this is the case that the photo has some tags
			if (nm2.length > 1) {
				// In case some tag has the same name as name of
				// photo,
				// we use substring but not replace to avoid
				// this error.
				// It really depends on the requirement since
				// you may
				// want to change the tag same as name when you
				// rename photos.
				int len = nm2[0].length();
				this.currentName = newName + this.currentName.substring(len);
				// this is the case that the photo doesn't have
				// any tag
				MyLogging.log(Level.FINE, "Only change the name " + "of photo to: " + newName + "\n");
			} else if (nm2.length == 1) {
				this.currentName = this.currentName.replace(nm2[0], newName);
			}
		}
		// Add the new date and the corresponding new name to map.
		this.nameHistory.put(date, this.currentName);
		DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		MyLogging.log(Level.FINE, "Put the name: " + this.currentName + " with coressponding date: "
				+ dateFormat.format(date) + " to the name history." + "\n");
		setChanged();
		notifyObservers(this);
	}

	/**
	 * Add new tags to the existing list of tags
	 * 
	 * @param tags:
	 *                the new tags to add to the list
	 */
	public void addTag(String[] tags) {
		String newName = "";
		if (tags.length != 0) {
			for (String tag : tags) {
				if (!this.tags.contains(tag)) {
					this.tags.add(tag);
					newName = newName + " @" + tag;
				}
			}
			newName = this.currentName + newName;
			Date date = new Date();
			renamePhoto(date, newName, false);
		}
	}

	/**
	 * Deleting tags for a photo
	 * 
	 * @param date:
	 *                the time when deleting tag
	 * @param tag:
	 *                the tags we want to delete
	 */
	public void deleteTag(String[] tags) {
		String newName = this.currNameWithoutTags;
		if (tags != null) {
			for (String tag : tags) {
				if (this.tags.contains(tag)) {
					this.tags.remove(tag);

				}
			}

		}
		for (String tag: this.tags){
			newName = newName + " @" + tag;
		}
		Date date = new Date();
		renamePhoto(date, newName, false);
	}

	public String getNameWOTags() {
		return this.currNameWithoutTags;
	}

	/**
	 * Retrieve a photo's name to a specific time Notice: Still consider
	 * there is a change of name at the time of retrieving so you need to
	 * add time stamp for the map. For Additional Features revert all
	 * changes.
	 * 
	 * @param date
	 */
	public void retriveName(Date date) {
		String rtname = this.nameHistory.get(date);
		Date date1 = new Date();
		renamePhoto(date1, rtname, false);
	}

	@Override
	public String toString() {
		String part1 = "photo path: ";
		String part2 = "name with tags: ";
		String part3 = "name without tags: ";
		String wholepart = part1 + this.photoPath + "\n" + part2 + this.currentName + "\n" + part3
				+ this.currNameWithoutTags;
		return wholepart;
	}

	/**
	 * Find the number of tags with another photo in common
	 * 
	 * @param photo2:
	 *                another photo
	 * @return : the number of tags in common
	 */
	public int findCommonTags(Photo photo2) {
		// This may be helpful in additionalmanagerfunction.
		Set<String> tags2 = photo2.getTags();
		Set<String> comtags = new HashSet<String>(this.tags);
		comtags.retainAll(tags2);
		return comtags.size();
	}

	public String getPhotoPath() {
		return this.photoPath;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((photoPath == null) ? 0 : photoPath.hashCode());
		return result;
	}

	// If two photos have the same path, then they are equal.
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Photo other = (Photo) obj;
		if (photoPath == null) {
			if (other.photoPath != null)
				return false;
		} else if (!photoPath.equals(other.photoPath))
			return false;
		return true;
	}
}
